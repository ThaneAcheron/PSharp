// ------------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the repo root for full license information.
// ------------------------------------------------------------------------------------------------

using System.Timers;

namespace Microsoft.PSharp.Timers
{
    /// <summary>
    /// Wrapper class for a system timer.
    /// </summary>
    public class ProductionTimerMachine : Machine
    {
        /// <summary>
        /// Machine to which eTimeout events are dispatched.
        /// </summary>
        private MachineId Client;

        /// <summary>
        /// System timer to generate elapsed timeout events in production mode.
        /// </summary>
        private Timer Timer;

        /// <summary>
        /// The id of the timer.
        /// </summary>
        private TimerId TimerId;

        /// <summary>
        /// Specified if periodic timeout events are desired.
        /// </summary>
        private bool IsPeriodic;

        /// <summary>
        /// Specify the periodicity of timeout events.
        /// </summary>
        private int Period;

        /// <summary>
        /// Flag to prevent timeout events being sent after stopping the timer.
        /// </summary>
        private bool IsTimerEnabled = false;

        /// <summary>
        /// Used to synchronize the Elapsed event handler with timer stoppage.
        /// </summary>
        private object Lock;

        /// <summary>
        /// The only state of the timer.
        /// </summary>
        [Start]
        [OnEntry(nameof(InitializeTimer))]
        [OnEventDoAction(typeof(HaltTimerEvent), nameof(DisposeTimer))]
        private class Init : MachineState
        {
        }

        /// <summary>
        /// Initializes the timer.
        /// </summary>
        private void InitializeTimer()
        {
            InitTimerEvent e = this.ReceivedEvent as InitTimerEvent;
            this.Client = e.Client;
            this.Timer = new Timer(e.Period);
            this.TimerId = e.TimerId;
            this.IsPeriodic = e.IsPeriodic;
            this.Period = e.Period;
            this.IsTimerEnabled = true;
            this.Lock = new object();

            if (!this.IsPeriodic)
            {
                this.Timer.AutoReset = false;
            }

            this.Timer.Elapsed += this.ElapsedEventHandler;
            this.Timer.Start();
        }

        /// <summary>
        /// Handler for the Elapsed event generated by the system timer.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Object that contains the event data.</param>
        private void ElapsedEventHandler(object sender, ElapsedEventArgs e)
        {
            lock (this.Lock)
            {
                if (this.IsTimerEnabled)
                {
                    this.Runtime.SendEvent(this.Client, new TimerElapsedEvent(this.TimerId));
                }
            }
        }

        /// <summary>
        /// Disposes the timer.
        /// </summary>
        private void DisposeTimer()
        {
            HaltTimerEvent e = this.ReceivedEvent as HaltTimerEvent;

            // The client attempting to stop this timer must be the one who created it.
            this.Assert(e.Client == this.Client);

            lock (this.Lock)
            {
                this.IsTimerEnabled = false;
                this.Timer.Stop();
                this.Timer.Dispose();
            }

            // If the client wants to flush the inbox, send a markup event.
            // This marks the endpoint of all timeout events sent by this machine.
            if (e.Flush)
            {
                this.Send(this.Client, new MarkupEvent());
            }

            // Stop this machine.
            this.Raise(new Halt());
        }
    }
}
