//-----------------------------------------------------------------------
// <copyright file="Timers.cs">
//      Copyright (c) Microsoft Corporation. All rights reserved.
// 
//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Timers;

namespace Microsoft.PSharp.Timers
{
	/// <summary>
	/// Extends the P# Machine with a simple timer.
	/// </summary>
	public abstract class TMachine : Machine
	{
		#region static fields

		/// <summary>
		/// False if machines are running in production mode.
		/// </summary>
		public static bool IsTestingMode;
		#endregion

		#region Timer API
		
		/// <summary>
		/// Start a timer. 
		/// Depending on IsTestingMode, either a timer model is used, or the system timer is.
		/// </summary>
		/// <param name="IsPeriodic">Specifies whether a periodic timer is desired.</param>
		/// <param name="period">For a periodic production timer, specifies the periodicity of the timeout events.</param>
		/// <returns>The machine id of the created timer. Must be passed while stopping the timer.</returns>
		protected MachineId StartTimer(bool IsPeriodic, int period)
		{
			// Use a model timer in testing mode
			if (IsTestingMode)
			{ 
				MachineId modelTimer = this.CreateMachine(typeof(TimerModel), new InitTimer(this.Id, IsPeriodic));
				return modelTimer;
			}

			// In production, use a system timer
			else
			{
				MachineId prodTimer = this.CreateMachine(typeof(TimerProduction), new InitTimer(this.Id, IsPeriodic, period));
				return prodTimer;
			}
		}

		/// <summary>
		/// Start a timer.
		/// </summary>
		/// <param name="IsPeriodic">Specifies whether a periodic timer is desired. A default period of 100ms is assumed.</param>
		/// <returns></returns>
		protected MachineId StartTimer(bool IsPeriodic)
		{
			return this.StartTimer(IsPeriodic, 100);
		}

		/// <summary>
		/// Stop the timer.
		/// </summary>
		/// <param name="timer">Id of the timer machine which is being stopped.</param>
		/// <param name="flush">Clear the queue of all timeout events generated by "timer".</param>
		protected async void StopTimer(MachineId timer, bool flush)
		{
			if(IsTestingMode)
			{
				this.Send(timer, new HaltTimer(this.Id));
			}
			else
			{
				this.Runtime.SendEvent(timer, new HaltTimer(this.Id));
			}

			// Flush the input queue of the relevant timeout events.
			// Send a markup event. Keep flushing eTimeout events with id==timer, until we see the markup event again.
			// eTimeout events from timers with differed id are restored to the queue.
			if(IsTestingMode)
			{
				this.Send(this.Id, new Markup());

				while (true)
				{
					Event e = await this.Receive(typeof(Markup), typeof(eTimeout));
					if(e is Markup)
					{
						break;
					}
					else if(e is eTimeout && ((e as eTimeout).id != timer))
					{
						this.Send(this.Id, e);
					}
					else
					{
						continue;
					}
				}
			}
			// use Runtime.SendEvent in production mode
			else
			{
				this.Runtime.SendEvent(this.Id, new Markup());

				while (true)
				{
					Event e = await this.Receive(Tuple<typeof(Markup), true>);
					if (e is Markup)
					{
						break;
					}
					else if (e is eTimeout && ((e as eTimeout).id != timer))
					{
						this.Runtime.SendEvent(this.Id, e);
					}
					else
					{
						continue;
					}
				}
			}
		}
		#endregion
	}
}