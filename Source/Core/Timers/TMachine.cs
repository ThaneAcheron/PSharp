//-----------------------------------------------------------------------
// <copyright file="Timers.cs">
//      Copyright (c) Microsoft Corporation. All rights reserved.
// 
//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Timers;
using System.Collections.Generic;

namespace Microsoft.PSharp.Timers
{
	/// <summary>
	/// Extends the P# Machine with a simple timer.
	/// </summary>
	public abstract class TMachine : Machine
	{
		#region static fields

		/// <summary>
		/// False if machines are running in production mode.
		/// </summary>
		public static bool IsTestingMode;
		#endregion

		#region private fields

		/// <summary>
		/// Set of currently active timers.
		/// </summary>
		HashSet<MachineId> timers = new HashSet<MachineId>();

		#endregion

		#region Timer API

		/// <summary>
		/// Start a timer. 
		/// Depending on IsTestingMode, either a timer model is used, or the system timer is.
		/// </summary>
		/// <param name="IsPeriodic">Specifies whether a periodic timer is desired.</param>
		/// <param name="period">For a periodic production timer, specifies the periodicity of the timeout events.</param>
		/// <returns>The machine id of the created timer. Must be passed while stopping the timer.</returns>
		protected MachineId StartTimer(bool IsPeriodic, int period)
		{
			// The specified period must be valid
			this.Assert(period >= 0);

			// Use a model timer in testing mode
			if (IsTestingMode)
			{ 
				MachineId modelTimer = this.CreateMachine(typeof(TimerModel), new InitTimer(this.Id, IsPeriodic));
				timers.Add(modelTimer);
				return modelTimer;
			}

			// In production, use a system timer
			else
			{
				MachineId prodTimer = this.CreateMachine(typeof(TimerProduction), new InitTimer(this.Id, IsPeriodic, period));
				timers.Add(prodTimer);
				return prodTimer;
			}
		}

		/// <summary>
		/// Start a timer.
		/// </summary>
		/// <param name="IsPeriodic">Specifies whether a periodic timer is desired. A default period of 100ms is assumed.</param>
		/// <returns></returns>
		protected MachineId StartTimer(bool IsPeriodic)
		{
			return this.StartTimer(IsPeriodic, 100);
		}

		/// <summary>
		/// Stop the timer.
		/// </summary>
		/// <param name="timer">Id of the timer machine which is being stopped.</param>
		/// <param name="flush">Clear the queue of all timeout events generated by "timer".</param>
		protected async void StopTimer(MachineId timer, bool flush)
		{
			// Check if the user is indeed trying to halt a valid timer
			this.Assert(timers.Contains(timer));
			timers.Remove(timer);

			this.Send(timer, new HaltTimer(this.Id, flush));

			// Flush the buffer: the timer being stopped sends a markup event to the inbox of this machine.
			// Keep dequeuing eTimeout events (with payload being the timer being stopped), until we see the markup event.
			if (flush)
			{
				while ((await this.Receive(typeof(Markup), typeof(eTimeout)) is Markup)) { }
			}
		}
		#endregion
	}
}