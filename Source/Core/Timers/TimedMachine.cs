// ------------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the repo root for full license information.
// ------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Microsoft.PSharp.Timers
{
    /// <summary>
    /// Extends the P# Machine with a simple timer.
    /// </summary>
    public abstract class TimedMachine : Machine
    {
        /// <summary>
        /// Set of currently active timers.
        /// </summary>
        private readonly HashSet<TimerId> Timers = new HashSet<TimerId>();

        /// <summary>
        /// Start a timer.
        /// </summary>
        /// <param name="payload">Payload of the timeout event.</param>
        /// <param name="period">Periodicity of the timeout events in ms.</param>
        /// <param name="isPeriodic">Specifies whether a periodic timer is desired.</param>
        /// <returns>The id of the created timer.</returns>
        protected TimerId StartTimer(object payload, int period, bool isPeriodic)
        {
            // The specified period must be valid
            this.Assert(period >= 0, "Timer period must be non-negative");

            var mid = this.Runtime.CreateMachineId(this.Runtime.GetTimerMachineType());
            var tid = new TimerId(mid, payload);

            this.Runtime.CreateMachine(mid, this.Runtime.GetTimerMachineType(), new InitTimerEvent(this.Id, tid, isPeriodic, period));

            this.Timers.Add(tid);
            return tid;
        }

        /// <summary>
        /// Stop the timer.
        /// </summary>
        /// <param name="timer">Id of the timer machine which is being stopped.</param>
        /// <param name="flush">Clear the queue of all timeout events generated by "timer".</param>
        protected async Task StopTimer(TimerId timer, bool flush = true)
        {
            // Check if the user is indeed trying to halt a valid timer
            this.Assert(this.Timers.Contains(timer), "Illegal timer-id given to StopTimer");
            this.Timers.Remove(timer);

            this.Send(timer.MachineId, new HaltTimerEvent(this.Id, flush));

            // Flush the buffer: the timer being stopped sends a markup event to the inbox of this machine.
            // Keep dequeuing eTimeout events (with payload being the timer being stopped), until we see the markup event.
            if (flush)
            {
                while (true)
                {
                    var ev = await this.Receive(Tuple.Create(typeof(MarkupEvent), new Func<Event, bool>(e => true)),
                        Tuple.Create(typeof(TimerElapsedEvent), new Func<Event, bool>(e => (e as TimerElapsedEvent).Tid == timer)));

                    if (ev is MarkupEvent)
                    {
                        break;
                    }
                }
            }
        }
    }
}